---
title: "Vignette for penalizedclr"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{penalizedclr}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,eval =FALSE,
  comment = "#>"
)
```

## Introduction

The R package <tt>penalizedclr</tt> provides an implementation of the penalized logistic regression model for matched case-control studies. The implementation allows for different penalties for different blocks of covariates, and  is therefore particularly useful in the presence of multi-source omics data. Both L1 and L2 penalties are implemented. 
Additionally, the package implements stability selection for variable selection in the penalized conditional regression model. 


## Installation

You can install the released version of <tt>penalizedclr</tt> from [CRAN](https://CRAN.R-project.org) with:


```{r eval = FALSE}
install.packages("penalizedclr")
```


And the development version from [GitHub](https://github.com/) with:

```{r eval = FALSE}
library(devtools)
install_github("veradjordjilovic/penalizedclr")
```

Load the package with: 

```{r setup}
library(penalizedclr)
```

## The setting
Assume that we have $K$ independent matched case-control pairs $(Y_{ki}, X_{ki})$, where $Y_{ki}$ is a binary variable indicating case control status (1 if case, 0 if control) and $X_{ki}$ is the associated $p$-dimensional vector of covariates. The conditional logistic regression models the probability of being a case given that the observation belongs to the $i$-th pair as:
$$
{\mathrm {logit}}\left[P(Y_{ki}=1 \mid S=i)\right] = \beta_{0i} + \beta^{T}X_{ki},
$$
where $S$ is the matched pair id,  $\beta_{0i}$ is the pair specific intercept and $\beta$ is a $p$-dimensional vector of fixed effects. 

In the present package we: 

* estimate $\beta$ in the high dimensional setting in which the number of covariates $p$ is much higher than the number of pairs $K$. We consider a penalized conditional logistic regression, which adds a penalty to the conditional log likelihood. Motivated by current medical applications considering clinical and molecular data,  we allow $X_{ki}$ to be a merge of different data sources to be penalized differently;

* perform stability selection to identify important variables (variables with nonzero regression coefficients) in the above conditional logistic regression. 



## Examples
In this section we will provide examples of  fitting a penalized conditional regression model with source-specific penalty parameters and performing variable selection with <tt>penalizedclr</tt>. Different choices will be explored for the type of penalty (L1 or elastic-net via $\alpha$) and for the choice of penalty parameters $\lambda$. We will show how to include information about the different blocks of data and how to specify source-specific penalties. 

Initial settings and libraries to be loaded:

```{r message=FALSE, warning=FALSE}
set.seed(123)
require(tidyverse)
```

### Data simulation

We simulate a simple multi-source data set, with two groups of covariates. As specified above, each case is matched to a control, and the probability of being a case in each stratum (case-control pair) is obtained from the linear predictor. An intercept is generated independently for each stratum.

```{r}
# two groups of predictors
p <- c(80, 20)

# percent of non-null variables
p_nz <- c(0.2, 0.8)
m_nz <- round(p*p_nz, 0)

# number of different strata (typically case-control pairs)
K <- 125

# number of cases and controls in each stratum
n_cases <- 1
n_ctrl <- 1


# covariates
X = cbind(matrix(rnorm(p[1] * K * (n_cases + n_ctrl), 0, 1), ncol = p[1]),
          matrix(rnorm(p[2] * K * (n_cases + n_ctrl), 0, 2), ncol = p[2]))

# coefficients
beta <- as.matrix(c(rnorm(m_nz[1], 0, 0.8),
                    rep(0, p[1] - m_nz[1]),
                    rnorm(m_nz[2], 0.1, 0.4),
                    rep(0, p[2] - m_nz[2])), ncol = 1)

beta_stratum <- rep(rnorm(K, 0, 2), each= n_cases+n_ctrl)

# stratum membership
stratum <- rep(1:K, each= n_cases+n_ctrl)

# linear predictor
lin_pred <- beta_stratum + X %*% beta

prob_case <- exp(lin_pred) / (1 + exp(lin_pred))


# generate the response

Y <- rep(0, length(stratum))

data_sim <- as_tibble(data.frame(stratum = stratum, probability = prob_case,
                                 obs_id = 1 : length(stratum)))
data_sim_cases <- data_sim %>%
  group_by(stratum)%>%
  sample_n(n_cases, weight = probability)

Y[data_sim_cases$obs_id] <- 1
```

### Penalized conditional logistic regression model: model fit

The function <tt>penalized.clr</tt>  fits a penalized conditional logistic regression model with different penalties for different blocks of covariates. The L1 penalty parameter `lambda` can be specified by the user or computed internally. In the latter case, to obtain a reasonable value of L1 penalty, cross-validation is performed  for each data layer separately. It is also possible to apply elastic net penalty through parameter `alpha`. 


#### Case 1: Penalty parameters provided by the user

Penalty parameters are specified for each data source, i.e., a block of covariates. This code illustrates how to fit <tt>penalized.clr</tt> with penalty parameters specified by the user. Here <tt>Y</tt> is the response vector, <tt>X</tt> is the multi-source matrix of covariates, <tt>stratum</tt> is the vector of ids of the matching pairs, and <tt>p</tt> is the vector of block dimensions. It has  the same dimension as the vector of penalty parameters <tt>lambda</tt>. It is possible to standardize the variables by setting <tt>standardize = TRUE</tt>  (<tt>FALSE</tt> by default).

```{r results = 'hide'}
fit1 <- penalized.clr(response = Y, penalized = X, stratum = stratum,
                      lambda = c(6,7), p = p, standardize = TRUE)

```
`fit1$penalized` is a numeric vector containing the regression coefficients for the penalized covariates.  We can, for instance,  compare estimated coefficients with the true coefficients (the ones that generated our data), by constructing a `2 x 2` contingency table cross-tabulating true and estimated non-zero coefficients:

```{r}
nonzero_index <- (beta != 0) * 1 #index of nonzero coefficients
table(fitted = (fit1$penalized != 0) * 1, nonzero_index)
```



#### Case 2: Penalty parameters computed internally

When the user does not specify the penalty parameters, they are computed internally for each data source separately based on cross-validation. 

```{r  results = 'hide'}
fit2 <- penalized.clr(response = Y, penalized = X, stratum = stratum,
                      p = p,
                      standardize = TRUE)

```

The selected penalty coefficients are: 

```{r}
fit2$lambda
```
The package uses fast cross-validation implemented in the R package <tt>clogitL1</tt>. 
We recommend to inspect manually the obtained `lambda` parameters. It is also recommended to investigate different ratios of data-source specific  penalties (see, for instance, Boulesteix et al. 2017 and examples therein). Note that cross validation depends on random data splits, and different runswill return different values of `lambda`. 





#### Case 3: Blocks not provided

This code shows what happens when no information is given about the blocks of predictors (`p`). In this case, all covariates are considered a single block and are penalized equally. 

```{r  results = 'hide'}
fit3 <- penalized.clr(response = Y, penalized = X, stratum = stratum,
                      standardize = TRUE)
```

The selected penalty coefficient is: 

```{r}
fit3$lambda
```






#### Case 4: One block of covariates not penalized

Somethimes,  a subset of covariates should be excluded from penalization. This can be achieved by specifying the `unpenalized` argument. In what follows, we penalize  the first block of covariates, and leave the remaining block unpenalized. 

```{r  results = 'hide'}
X1 <- X[, 1:p[1]]
X2 <- X[, (p[1]+1):(p[1]+p[2])]
fit4 <- penalized.clr(response = Y, penalized = X1, unpenalized = X2, 
                      stratum = stratum, p = p[1], 
                      standardize = TRUE)
```

This can be particularly useful when performing variable selection on omics variables (penalized) while adjusting for clinical covariates that should not be penalized. 

#### Case 5: Elastic net penalty

The package <tt>penalizedclr</tt>  is not limited to L1 or lasso penalty. While L1 penalty is more suited for variable selection, in the presence of highly correlated covariates, it can be useful to add some amount of  L2 penalty.  The two can be  combined in an elastic net framework by specifying  the mixing parameter `alpha`. Default `alpha=1` gives lasso. 

```{r  results = 'hide'}
fit2 <- penalized.clr(response = Y, penalized = X, stratum = stratum,
                      p = p,
                      standardize = TRUE, alpha = 0.6)
```


### Penalized conditional logistic regression model: stability selection

The function <tt>stable.clr</tt> performs stability selection ( Meinshausen and Bühlmann 2010 and  Shah and  Samworth 2013) for variable selection via penalized conditional logistic regression. For details on stability selection, we refer to the original publications. Briefly, for each combination of penalty parameters, $2B$ subsamples of  $\lfloor K/2 \rfloor$ matched pairs are taken and a penalized model is estimated. For each covariate and penalty combination, selection probability is computed as the proportion of estimated models in which the associated coefficient estimate is different from zero. Finally, the selection probability of a variable is obtained by taking the maximum selection probability over all considered penalty combinations. Parameter $B$ is set to 100 by default, but can be changed by the user. Note that this choice will have an impact on the computation time, and higher values of $B$ will lead to a slower computation.  The function returns a list containing the selection probabilities for each covariate, i.e. the proportion of estimated models in which the associated coefficient estimate is different from zero. 
The user can then set a desired threshold for  selection probability to obtain the set of selected covariates. 

#### Case 1: penalty parameters given by user

The following code performs stability selection when all covariates are considered as a single block (a single data source) and a sequence of L1 penalties contains only 2 values.

```{r}
stable1 <- stable.clr(response = Y,
                      penalized = X, stratum = stratum,
                      lambda.seq = c(10,20))
```
To inspect the results, we can, for instance, print the covariates with selection probability higher than 0.6:

```{r}
which(stable1$P>0.6)

```



#### Case 2: penalty parameters computed externally

It is possible to obtain the sequence of L1 penalty parameters via the function <tt>find.default.lambda</tt>. It relies on the `cv.clogitL1` function of the `clogitL1` package to perform cross-validation to determine a suitable `lambda` sequence. The number of folds is set to 10 by default but can also be specified by the user.

```{r}
lambda.seq <- find.default.lambda(response = Y, 
                                  stratum = stratum, 
                                  penalized = X, 
                                  alpha=1,
                                  nfolds = 10)

lambda.seq
```

```{r}
stable2 <- stable.clr(response = Y,
                      penalized = X, stratum = stratum,
                      lambda.seq = lambda.seq)
```

Covariates with selection probability higher than 0.6:

```{r}
which(stable2$P>0.6)

```

#### Case 3: penalty parameters computed internally

If we do not specify how to compute the penalty parameters as in case 2, <tt>stable.clr</tt> will compute them by default by using <tt>find.default.lambda</tt> with default options. We only need to run: 

```{r}
stable3 <- stable.clr(response = Y,
                      penalized = X, 
                      stratum = stratum)
```

The selected sequence of `lambda` is: 

```{r}
stable3$lambda.seq
```


Covariates with selection probability higher than 0.6:

```{r}
which(stable3$P>0.6)

```



#### Case 4: covariates divided into blocks

This code implements stability selection for variable selection via penalized conditional logistic regression taking into account the block structure of covariates ($p$). We compute  data-source specific sequences `lambda.seq` externally via <tt>find.default.lambda</tt> and then run <tt>stable.clr.g</tt>. This function is an extension of <tt>stable.clr</tt> that allows for different groups (blocks) of covariates.

```{r}

lambda.list <- find.default.lambda(response = Y,
                    penalized = X, stratum = stratum,
                    p = p)

lambda.list
```


```{r}
stable.g1 <- stable.clr.g(response = Y,
                          penalized = X,
                          stratum = stratum,
                          p = p,
                          lambda.list = lambda.list)
```


```{r}

which(stable.g1$P>0.6)
```
Note that if $p$ is not specified, the package will automatically run <tt>stable.clr</tt> and apply equal penalties for all covariates. 

# References


1. Boulesteix, A. L., De Bin, R., Jiang, X., & Fuchs, M. (2017). IPF-LASSO: Integrative-penalized regression with penalty factors for prediction based on multi-omics data. Computational and mathematical methods in medicine, 2017.

2. Meinshausen, N., & Bühlmann, P. (2010). Stability selection.
Journal of the Royal Statistical Society: Series B (Statistical Methodology), 72(4), 417-473.

3.  Shah, R. D., & Samworth, R. J. (2013). Variable selection with error control:
another look at stability selection. Journal of the Royal Statistical Society: Series B (Statistical Methodology), 75(1), 55-80.

